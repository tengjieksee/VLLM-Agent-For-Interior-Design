{"version":3,"file":"types.cjs","names":["z","toolHooksSchema","outputHandling: OutputHandling | undefined","applyDefaults: boolean","resolved: DetailedOutputHandling","base: OutputHandling | undefined","override: OutputHandling | undefined"],"sources":["../src/types.ts"],"sourcesContent":["import { z } from \"zod/v3\";\nimport type { OAuthClientProvider } from \"@modelcontextprotocol/sdk/client/auth.js\";\nimport type {\n  ContentBlock,\n  ToolMessage,\n  MessageStructure,\n} from \"@langchain/core/messages\";\nimport type { RunnableConfig } from \"@langchain/core/runnables\";\nimport type { Command, CommandParams } from \"@langchain/langgraph\";\n\nimport { toolHooksSchema, type ToolHooks } from \"./hooks.js\";\n\nexport type {\n  Command,\n  ContentBlock,\n  ToolMessage,\n  MessageStructure,\n  RunnableConfig,\n  CommandParams,\n};\n\nconst callToolResultContentTypes = [\n  \"audio\",\n  \"image\",\n  \"resource\",\n  \"resource_link\",\n  \"text\",\n] as const;\nexport type CallToolResultContentType =\n  (typeof callToolResultContentTypes)[number];\n\n/**\n * The severity of a log message.\n * @see {@link https://github.com/modelcontextprotocol/typescript-sdk/blob/main/src/types.ts#L1067}\n */\nexport const LoggingLevelSchema = z.enum([\n  \"debug\",\n  \"info\",\n  \"notice\",\n  \"warning\",\n  \"error\",\n  \"critical\",\n  \"alert\",\n  \"emergency\",\n]);\n\n/**\n * A uniquely identifying ID for a request in JSON-RPC.\n * @see {@link https://github.com/modelcontextprotocol/typescript-sdk/blob/main/src/types.ts#L71C1-L74C72}\n */\nexport const RequestIdSchema = z.union([z.string(), z.number().int()]);\n\nconst outputTypesUnion = z.union([\n  z\n    .literal(\"content\")\n    .describe(\"Put tool output into the ToolMessage.content array\"),\n  z\n    .literal(\"artifact\")\n    .describe(\"Put tool output into the ToolMessage.artifact array\"),\n]);\n\nconst detailedOutputHandlingSchema = z.object(\n  Object.fromEntries(\n    callToolResultContentTypes.map((contentType) => [\n      contentType,\n      z\n        .union([\n          z\n            .literal(\"content\")\n            .describe(\n              `Put all ${contentType} tool output into the ToolMessage.content array`\n            ),\n          z\n            .literal(\"artifact\")\n            .describe(\n              `Put all ${contentType} tool output into the ToolMessage.artifact array`\n            ),\n        ])\n        .describe(\n          `Where to place ${contentType} tool output in the LangChain ToolMessage`\n        )\n        .optional(),\n    ])\n  ) as {\n    [K in CallToolResultContentType]: z.ZodOptional<\n      z.ZodUnion<[z.ZodLiteral<\"content\">, z.ZodLiteral<\"artifact\">]>\n    >;\n  }\n);\n\nexport type DetailedOutputHandling = z.output<\n  typeof detailedOutputHandlingSchema\n>;\n\nexport const outputHandlingSchema = z\n  .union([outputTypesUnion, detailedOutputHandlingSchema])\n  .describe(\n    \"Defines where to place each tool output type in the LangChain ToolMessage.\\n\\n\" +\n      \"Items in the `content` field will be used as input context for the LLM, while the artifact field is\\n\" +\n      \"used for capturing tool output that won't be shown to the model, to be used in some later workflow\\n\" +\n      \"step.\\n\\n\" +\n      \"For example, imagine that you have a SQL query tool that can return huge result sets. Rather than\\n\" +\n      \"sending these large outputs directly to the model, perhaps you want the model to be able to inspect\\n\" +\n      \"the output in a code execution environment. In this case, you would set the output handling for the\\n\" +\n      \"`resource` type to `artifact` (it's default value), and then upon initialization of your code\\n\" +\n      \"execution environment, you would look through your message history for `ToolMessage`s with the\\n\" +\n      \"`artifact` field set to `resource`, and use the `content` field during initialization of the\\n\" +\n      \"environment.\"\n  );\n\n/**\n * Defines where to place each tool output type in the LangChain ToolMessage.\n *\n * Can be set to `content` or `artifact` to send all tool output into the ToolMessage.content or\n * ToolMessage.artifact array, respectively, or you can assign an object that maps each content type\n * to `content` or `artifact`.\n *\n * @default {\n *   \"text\": \"content\",\n *   \"image\": \"content\",\n *   \"audio\": \"content\",\n *   \"resource\": \"artifact\"\n * }\n *\n * Items in the `content` field will be used as input context for the LLM, while the artifact field is\n * used for capturing tool output that won't be shown to the model, to be used in some later workflow\n * step.\n *\n * For example, imagine that you have a SQL query tool that can return huge result sets. Rather than\n * sending these large outputs directly to the model, perhaps you want the model to be able to inspect\n * the output in a code execution environment. In this case, you would set the output handling for the\n * `resource` type to `artifact` (its default value), and then upon initialization of your code\n * execution environment, you would look through your message history for `ToolMessage`s with the\n * `artifact` field set to `resource`, and use the `content` field during initialization of the\n * environment.\n */\nexport type OutputHandling = z.output<typeof outputHandlingSchema>;\n\n/**\n * Zod schema for validating OAuthClientProvider interface\n * Since OAuthClientProvider has methods, we create a custom validator\n */\nexport const oAuthClientProviderSchema = z.custom<OAuthClientProvider>(\n  (val) => {\n    if (!val || typeof val !== \"object\") return false;\n\n    // Check required properties and methods exist\n    const requiredMethods = [\n      \"redirectUrl\",\n      \"clientMetadata\",\n      \"clientInformation\",\n      \"tokens\",\n      \"saveTokens\",\n    ];\n\n    // redirectUrl can be a string, URL, or getter returning string/URL\n    if (!(\"redirectUrl\" in val)) return false;\n\n    // clientMetadata can be an object or getter returning an object\n    if (!(\"clientMetadata\" in val)) return false;\n\n    // Check that required methods exist (they can be functions or getters)\n    for (const method of requiredMethods) {\n      if (!(method in val)) return false;\n    }\n\n    return true;\n  },\n  {\n    message:\n      \"Must be a valid OAuthClientProvider implementation with required properties: redirectUrl, clientMetadata, clientInformation, tokens, saveTokens\",\n  }\n);\n\nexport const baseConfigSchema = z.object({\n  /**\n   * Defines where to place each tool output type in the LangChain ToolMessage.\n   *\n   * Can be set to `content` or `artifact` to send all tool output into the ToolMessage.content or\n   * ToolMessage.artifact array, respectively, or you can assign an object that maps each content type\n   * to `content` or `artifact`.\n   *\n   * @default {\n   *   \"text\": \"content\",\n   *   \"image\": \"content\",\n   *   \"audio\": \"content\",\n   *   \"resource\": \"artifact\"\n   * }\n   *\n   * Items in the `content` field will be used as input context for the LLM, while the artifact field is\n   * used for capturing tool output that won't be shown to the model, to be used in some later workflow\n   * step.\n   *\n   * For example, imagine that you have a SQL query tool that can return huge result sets. Rather than\n   * sending these large outputs directly to the model, perhaps you want the model to be able to inspect\n   * the output in a code execution environment. In this case, you would set the output handling for the\n   * `resource` type to `artifact` (its default value), and then upon initialization of your code\n   * execution environment, you would look through your message history for `ToolMessage`s with the\n   * `artifact` field set to `resource`, and use the `content` field during initialization of the\n   * environment.\n   */\n  outputHandling: outputHandlingSchema.optional(),\n\n  /**\n   * Default timeout in milliseconds for tool execution. Must be greater than 0.\n   * If not specified, tools will use their own configured timeout values.\n   */\n  defaultToolTimeout: z.number().min(1).optional(),\n});\n\n/**\n * Stdio transport restart configuration\n */\nexport const stdioRestartSchema = z\n  .object({\n    /**\n     * Whether to automatically restart the process if it exits\n     */\n    enabled: z\n      .boolean()\n      .describe(\"Whether to automatically restart the process if it exits\")\n      .optional(),\n    /**\n     * Maximum number of restart attempts\n     */\n    maxAttempts: z\n      .number()\n      .describe(\"The maximum number of restart attempts\")\n      .optional(),\n    /**\n     * Delay in milliseconds between restart attempts\n     */\n    delayMs: z\n      .number()\n      .describe(\"The delay in milliseconds between restart attempts\")\n      .optional(),\n  })\n  .describe(\"Configuration for stdio transport restart\");\n\n/**\n * Stdio transport connection\n */\nexport const stdioConnectionSchema = z\n  .object({\n    /**\n     * Optional transport type, inferred from the structure of the config if not provided. Included\n     * for compatibility with common MCP client config file formats.\n     */\n    transport: z.literal(\"stdio\").optional(),\n    /**\n     * Optional transport type, inferred from the structure of the config if not provided. Included\n     * for compatibility with common MCP client config file formats.\n     */\n    type: z.literal(\"stdio\").optional(),\n    /**\n     * The executable to run the server (e.g. `node`, `npx`, etc)\n     */\n    command: z.string().describe(\"The executable to run the server\"),\n    /**\n     * Array of command line arguments to pass to the executable\n     */\n    args: z\n      .array(z.string())\n      .describe(\"Command line arguments to pass to the executable\"),\n    /**\n     * Environment variables to set when spawning the process.\n     */\n    env: z\n      .record(z.string())\n      .describe(\"The environment to use when spawning the process\")\n      .optional(),\n    /**\n     * The encoding to use when reading from the process\n     */\n    encoding: z\n      .string()\n      .describe(\"The encoding to use when reading from the process\")\n      .optional(),\n    /**\n     * How to handle stderr of the child process. This matches the semantics of Node's `child_process.spawn`\n     *\n     * The default is \"inherit\", meaning messages to stderr will be printed to the parent process's stderr.\n     *\n     * @default \"inherit\"\n     */\n    stderr: z\n      .union([\n        z.literal(\"overlapped\"),\n        z.literal(\"pipe\"),\n        z.literal(\"ignore\"),\n        z.literal(\"inherit\"),\n      ])\n      .describe(\n        \"How to handle stderr of the child process. This matches the semantics of Node's `child_process.spawn`\"\n      )\n      .optional()\n      .default(\"inherit\"),\n    /**\n     * The working directory to use when spawning the process.\n     */\n    cwd: z\n      .string()\n      .describe(\"The working directory to use when spawning the process\")\n      .optional(),\n    /**\n     * Additional restart settings\n     */\n    restart: stdioRestartSchema.optional(),\n  })\n  .and(baseConfigSchema)\n  .describe(\"Configuration for stdio transport connection\");\n\n/**\n * Streamable HTTP transport reconnection configuration\n */\nexport const streamableHttpReconnectSchema = z\n  .object({\n    /**\n     * Whether to automatically reconnect if the connection is lost\n     */\n    enabled: z\n      .boolean()\n      .describe(\"Whether to automatically reconnect if the connection is lost\")\n      .optional(),\n    /**\n     * Maximum number of reconnection attempts\n     */\n    maxAttempts: z\n      .number()\n      .describe(\"The maximum number of reconnection attempts\")\n      .optional(),\n    /**\n     * Delay in milliseconds between reconnection attempts\n     */\n    delayMs: z\n      .number()\n      .describe(\"The delay in milliseconds between reconnection attempts\")\n      .optional(),\n  })\n  .describe(\"Configuration for streamable HTTP transport reconnection\");\n\n/**\n * Streamable HTTP transport connection\n */\nexport const streamableHttpConnectionSchema = z\n  .object({\n    /**\n     * Optional transport type, inferred from the structure of the config. If \"sse\", will not attempt\n     * to connect using streamable HTTP.\n     */\n    transport: z.union([z.literal(\"http\"), z.literal(\"sse\")]).optional(),\n    /**\n     * Optional transport type, inferred from the structure of the config. If \"sse\", will not attempt\n     * to connect using streamable HTTP.\n     */\n    type: z.union([z.literal(\"http\"), z.literal(\"sse\")]).optional(),\n    /**\n     * The URL to connect to\n     */\n    url: z.string().url(),\n    /**\n     * Additional headers to send with the request, useful for authentication\n     */\n    headers: z.record(z.string()).optional(),\n    /**\n     * OAuth client provider for automatic authentication handling.\n     * When provided, the transport will automatically handle token refresh,\n     * 401 error retries, and OAuth 2.0 flows according to RFC 6750.\n     * This is the recommended approach for authentication instead of manual headers.\n     */\n    authProvider: oAuthClientProviderSchema.optional(),\n    /**\n     * Additional reconnection settings.\n     */\n    reconnect: streamableHttpReconnectSchema.optional(),\n    /**\n     * Whether to automatically fallback to SSE if Streamable HTTP is not available or not supported\n     *\n     * @default true\n     */\n    automaticSSEFallback: z.boolean().optional().default(true),\n  })\n  .and(baseConfigSchema)\n  .describe(\"Configuration for streamable HTTP transport connection\");\n\n/**\n * Create combined schema for all transport connection types\n */\nexport const connectionSchema = z\n  .union([stdioConnectionSchema, streamableHttpConnectionSchema])\n  .describe(\"Configuration for a single MCP server\");\n\nconst toolSourceSchema = z.object({\n  type: z.literal(\"tool\"),\n  name: z.string(),\n  args: z.unknown(),\n  server: z.string(),\n});\n/**\n * we don't know yet what other types of sources may send progress messages\n */\nconst unknownSourceSchema = z.object({\n  type: z.literal(\"unknown\"),\n});\nconst eventContextSchema = z.union([toolSourceSchema, unknownSourceSchema]);\nexport type EventContext = z.output<typeof eventContextSchema>;\n\nconst serverMessageSourceSchema = z.object({\n  server: z.string(),\n  options: connectionSchema,\n});\nexport type ServerMessageSource = z.output<typeof serverMessageSourceSchema>;\n\nexport const notifications = z.object({\n  /**\n   * Called when a log message is received.\n   *\n   * @param logMessage - The log message\n   * @param logMessage.message - The log message\n   * @param logMessage.level - The log level\n   * @param logMessage.timestamp - The log timestamp\n   * @param source - The source of the log message\n   * @param source.server - The server of the source, e.g. \"my-server\"\n   * @param source.option - The connection options of the source, e.g. `{ transport: \"stdio\", command: \"node\", args: [\"server.js\"] }`\n   * @returns The log message\n   *\n   * @example\n   * ```ts\n   * const client = new MultiServerMCPClient({\n   *   // ...\n   *   onLog: (logMessage) => {\n   *     console.log(logMessage);\n   *   },\n   * });\n   * ```\n   */\n  onMessage: z\n    .function()\n    .args(\n      z.object({\n        /**\n         * The severity of this log message.\n         */\n        level: LoggingLevelSchema,\n        /**\n         * An optional name of the logger issuing this message.\n         */\n        logger: z.optional(z.string()),\n        /**\n         * The data to be logged, such as a string message or an object. Any JSON serializable type is allowed here.\n         */\n        data: z.unknown(),\n      }),\n      serverMessageSourceSchema\n    )\n    .returns(z.union([z.void(), z.promise(z.void())]))\n    .optional(),\n  /**\n   * Called when a progress message is received.\n   *\n   * @param progress - The progress message\n   * @param progress.message - The progress message\n   * @param progress.percentage - The progress percentage\n   * @param progress.timestamp - The progress timestamp\n   * @param source - The source of the progress message\n   * @param source.type - The type of the source, e.g. \"tool\"\n   * @param source.server - The server of the source, e.g. \"my-server\"\n   * @param source.name - The name of the source, e.g. \"my-name\"\n   * @param source.args - The arguments of the source, e.g. { a: 1, b: 2 }\n   * @returns The progress message\n   *\n   * @example\n   * ```ts\n   * const client = new MultiServerMCPClient({\n   *   // ...\n   *   onProgress: (progress, source) => {\n   *     if (source.type === \"tool\") {\n   *     console.log(progress);\n   *   },\n   * });\n   * ```\n   */\n  onProgress: z\n    .function()\n    .args(\n      z.object({\n        /**\n         * The progress thus far. This should increase every time progress is made, even if the total is unknown.\n         */\n        progress: z.number(),\n        /**\n         * Total number of items to process (or total progress required), if known.\n         */\n        total: z.optional(z.number()),\n        /**\n         * An optional message describing the current progress.\n         */\n        message: z.optional(z.string()),\n      }),\n      eventContextSchema\n    )\n    .returns(z.union([z.void(), z.promise(z.void())]))\n    .optional(),\n  onCancelled: z\n    .function()\n    .args(\n      z.object({\n        /**\n         * The ID of the request to cancel.\n         *\n         * This MUST correspond to the ID of a request previously issued in the same direction.\n         */\n        requestId: RequestIdSchema,\n\n        /**\n         * An optional string describing the reason for the cancellation. This MAY be logged or presented to the user.\n         */\n        reason: z.string().optional(),\n      }),\n      serverMessageSourceSchema\n    )\n    .returns(z.union([z.void(), z.promise(z.void())]))\n    .optional(),\n  /**\n   * Called when the server is initialized.\n   *\n   * @param source - The source of the initialized message\n   * @param source.server - The server of the source, e.g. \"my-server\"\n   * @param source.options - The connection options of the source, e.g. `{ transport: \"stdio\", command: \"node\", args: [\"server.js\"] }`, see {@link ServerMessageSource}\n   * @returns The initialized message\n   *\n   * @example\n   * ```ts\n   * const client = new MultiServerMCPClient({\n   *   // ...\n   *   onInitialized: (source) => {\n   *     console.log(source);\n   *   },\n   * });\n   * ```\n   */\n  onInitialized: z\n    .function()\n    .args(serverMessageSourceSchema)\n    .returns(z.union([z.void(), z.promise(z.void())]))\n    .optional(),\n  /**\n   * Called when the prompts list is changed.\n   *\n   * @param source - The source of the prompts list changed message\n   * @param source.server - The server of the source, e.g. \"my-server\"\n   * @param source.options - The connection options of the source, e.g. `{ transport: \"stdio\", command: \"node\", args: [\"server.js\"] }`, see {@link ServerMessageSource}\n   * @returns The prompts list changed message\n   *\n   * @example\n   * ```ts\n   * const client = new MultiServerMCPClient({\n   *   // ...\n   *   onPromptsListChanged: (source) => {\n   *     console.log(source);\n   *   },\n   * });\n   * ```\n   */\n  onPromptsListChanged: z\n    .function()\n    .args(serverMessageSourceSchema)\n    .returns(z.union([z.void(), z.promise(z.void())]))\n    .optional(),\n  /**\n   * Called when the resources list is changed.\n   *\n   * @param source - The source of the resources list changed message\n   * @param source.server - The server of the source, e.g. \"my-server\"\n   * @param source.options - The connection options of the source, e.g. `{ transport: \"stdio\", command: \"node\", args: [\"server.js\"] }`, see {@link ServerMessageSource}\n   * @returns The resources list changed message\n   *\n   * @example\n   * ```ts\n   * const client = new MultiServerMCPClient({\n   *   // ...\n   *   onResourcesListChanged: (source) => {\n   *     console.log(source);\n   *   },\n   * });\n   * ```\n   */\n  onResourcesListChanged: z\n    .function()\n    .args(serverMessageSourceSchema)\n    .returns(z.union([z.void(), z.promise(z.void())]))\n    .optional(),\n  /**\n   * Called when the resources are updated.\n   *\n   * @param updatedResource - The updated resource\n   * @param updatedResource.uri - The URI of the resource that has been updated. This might be a sub-resource of the one that the client actually subscribed to.\n   * @param source - The source of the resources updated message\n   * @param source.server - The server of the source, e.g. \"my-server\"\n   * @param source.options - The connection options of the source, e.g. `{ transport: \"stdio\", command: \"node\", args: [\"server.js\"] }`, see {@link ServerMessageSource}\n   * @returns The resources updated message\n   *\n   * @example\n   * ```ts\n   * const client = new MultiServerMCPClient({\n   *   // ...\n   *   onResourcesUpdated: (updatedResource, source) => {\n   *     console.log(`Resource ${updatedResource.uri} updated`);\n   *   },\n   * });\n   * ```\n   */\n  onResourcesUpdated: z\n    .function()\n    .args(\n      z.object({\n        /**\n         * The URI of the resource that has been updated. This might be a sub-resource of the one that the client actually subscribed to.\n         */\n        uri: z.string(),\n      }),\n      serverMessageSourceSchema\n    )\n    .returns(z.union([z.void(), z.promise(z.void())]))\n    .optional(),\n  /**\n   * Called when the roots list is changed.\n   *\n   * @param source - The source of the roots list changed message\n   * @param source.server - The server of the source, e.g. \"my-server\"\n   * @param source.options - The connection options of the source, e.g. `{ transport: \"stdio\", command: \"node\", args: [\"server.js\"] }`, see {@link ServerMessageSource}\n   * @returns The roots list changed message\n   *\n   * @example\n   * ```ts\n   * const client = new MultiServerMCPClient({\n   *   // ...\n   *   onRootsListChanged: (source) => {\n   *     console.log(source);\n   *   },\n   * });\n   * ```\n   */\n  onRootsListChanged: z\n    .function()\n    .args(serverMessageSourceSchema)\n    .returns(z.union([z.void(), z.promise(z.void())]))\n    .optional(),\n  /**\n   * Called when the tools list is changed.\n   *\n   * @param source - The source of the tools list changed message\n   * @param source.server - The server of the source, e.g. \"my-server\"\n   * @param source.options - The connection options of the source, e.g. `{ transport: \"stdio\", command: \"node\", args: [\"server.js\"] }`, see {@link ServerMessageSource}\n   * @returns The tools list changed message\n   *\n   * @example\n   * ```ts\n   * const client = new MultiServerMCPClient({\n   *   // ...\n   *   onToolsListChanged: (source) => {\n   *     console.log(source);\n   *   },\n   * });\n   * ```\n   */\n  onToolsListChanged: z\n    .function()\n    .args(serverMessageSourceSchema)\n    .returns(z.union([z.void(), z.promise(z.void())]))\n    .optional(),\n});\nexport type Notifications = z.output<typeof notifications>;\n\n/**\n * {@link MultiServerMCPClient} configuration\n */\nexport const clientConfigSchema = z\n  .object({\n    /**\n     * A map of server names to their configuration\n     */\n    mcpServers: z\n      .record(connectionSchema)\n      .describe(\"A map of server names to their configuration\"),\n    /**\n     * Whether to throw an error if a tool fails to load\n     *\n     * @default true\n     */\n    throwOnLoadError: z\n      .boolean()\n      .describe(\"Whether to throw an error if a tool fails to load\")\n      .optional()\n      .default(true),\n    /**\n     * Whether to prefix tool names with the server name. Prefixes are separated by double\n     * underscores (example: `calculator_server_1__add`).\n     *\n     * @default true\n     */\n    prefixToolNameWithServerName: z\n      .boolean()\n      .describe(\"Whether to prefix tool names with the server name\")\n      .optional()\n      .default(false),\n    /**\n     * An additional prefix to add to the tool name Prefixes are separated by double underscores\n     * (example: `mcp__add`).\n     *\n     * @default \"mcp\"\n     */\n    additionalToolNamePrefix: z\n      .string()\n      .describe(\"An additional prefix to add to the tool name\")\n      .optional()\n      .default(\"\"),\n    /**\n     * If true, the tool will use LangChain's standard multimodal content blocks for tools that output\n     * image or audio content, and embedded resources will be converted to `StandardFileBlock` objects.\n     * When `false`, all artifacts are left in their MCP format, but embedded resources will be\n     * converted to `StandardFileBlock` objects if {@link ClientConfig#outputHandling} causes embedded resources to\n     * be treated as content, as otherwise ChatModel providers will not be able to interpret them.\n     *\n     * @default false\n     */\n    useStandardContentBlocks: z\n      .boolean()\n      .describe(\n        \"If true, the tool will use LangChain's standard multimodal content blocks for tools that output\\n\" +\n          \"image or audio content. When true, embedded resources will be converted to `StandardFileBlock`\\n\" +\n          \"objects. When `false`, all artifacts are left in their MCP format, but embedded resources will\\n\" +\n          \"be converted to `StandardFileBlock` objects if `outputHandling` causes embedded resources to be\\n\" +\n          \"treated as content, as otherwise ChatModel providers will not be able to interpret them.\"\n      )\n      .optional()\n      .default(false),\n    /**\n     * Behavior when a server fails to connect.\n     * - \"throw\": Throw an error immediately if any server fails to connect (default)\n     * - \"ignore\": Skip failed servers and continue with successfully connected ones\n     * - Function: Custom error handler. If the function throws, the error is bubbled through.\n     *   If it returns normally, the server is treated as ignored and skipped.\n     *\n     * @default \"throw\"\n     */\n    onConnectionError: z\n      .union([\n        z.enum([\"throw\", \"ignore\"]),\n        z\n          .function()\n          .args(\n            z.object({\n              serverName: z.string(),\n              error: z.unknown(),\n            })\n          )\n          .returns(z.void()),\n      ])\n      .describe(\n        \"Behavior when a server fails to connect: 'throw' to error immediately, 'ignore' to skip failed servers, or a function for custom error handling\"\n      )\n      .optional()\n      .default(\"throw\"),\n  })\n  .and(baseConfigSchema)\n  .and(toolHooksSchema)\n  .and(notifications)\n  .describe(\"Configuration for the MCP client\");\n\n/**\n * Configuration for stdio transport connection\n */\nexport type StdioConnection = z.input<typeof stdioConnectionSchema>;\n\n/**\n * Type for {@link StdioConnection} with default values applied.\n */\nexport type ResolvedStdioConnection = z.output<typeof stdioConnectionSchema>;\n\n/**\n * Configuration for streamable HTTP transport connection\n */\nexport type StreamableHTTPConnection = z.input<\n  typeof streamableHttpConnectionSchema\n>;\n\n/**\n * Type for {@link StreamableHTTPConnection} with default values applied.\n */\nexport type ResolvedStreamableHTTPConnection = z.output<\n  typeof streamableHttpConnectionSchema\n>;\n\n/**\n * Union type for all transport connection types\n */\nexport type Connection = z.input<typeof connectionSchema>;\n\n/**\n * Type for {@link MultiServerMCPClient} configuration\n */\nexport type ClientConfig = z.input<typeof clientConfigSchema>;\n\n/**\n * Type for {@link Connection} with default values applied.\n */\nexport type ResolvedConnection = z.output<typeof connectionSchema>;\n\n/**\n * Type for {@link MultiServerMCPClient} configuration, with default values applied.\n */\nexport type ResolvedClientConfig = z.output<typeof clientConfigSchema>;\n\n/**\n * Custom error handler function for connection errors.\n * If the function throws, the error is bubbled through.\n * If it returns normally, the server is treated as ignored and skipped.\n *\n * @param params - Error handler parameters\n * @param params.serverName - The name of the server that failed to connect\n * @param params.error - The error that occurred during connection\n */\nexport type ConnectionErrorHandler = (params: {\n  serverName: string;\n  error: unknown;\n}) => void;\n\nexport type LoadMcpToolsOptions = {\n  /**\n   * If true, throw an error if a tool fails to load.\n   *\n   * @default true\n   */\n  throwOnLoadError?: boolean;\n\n  /**\n   * If true, the tool name will be prefixed with the server name followed by a double underscore.\n   * This is useful if you want to avoid tool name collisions across servers.\n   *\n   * @default false\n   */\n  prefixToolNameWithServerName?: boolean;\n\n  /**\n   * An additional prefix to add to the tool name. Will be added at the very beginning of the tool\n   * name, separated by a double underscore.\n   *\n   * For example, if `additionalToolNamePrefix` is `\"mcp\"`, and `prefixToolNameWithServerName` is\n   * `true`, the tool name `\"my-tool\"` provided by server `\"my-server\"` will become\n   * `\"mcp__my-server__my-tool\"`.\n   *\n   * Similarly, if `additionalToolNamePrefix` is `mcp` and `prefixToolNameWithServerName` is false,\n   * the tool name would be `\"mcp__my-tool\"`.\n   *\n   * @default \"\"\n   */\n  additionalToolNamePrefix?: string;\n\n  /**\n   * If true, the tool will use LangChain's standard multimodal content blocks for tools that output\n   * image or audio content, and embedded resources will be converted to `StandardFileBlock` objects.\n   * When `false`, all artifacts are left in their MCP format, but embedded resources will be\n   * converted to `StandardFileBlock` objects if {@link outputHandling} causes embedded resources to\n   * be treated as content, as otherwise ChatModel providers will not be able to interpret them.\n   *\n   * @default false\n   */\n  useStandardContentBlocks?: boolean;\n\n  /**\n   * Defines where to place each tool output type in the LangChain ToolMessage.\n   *\n   * @default {\n   *   \"text\": \"content\",\n   *   \"image\": \"content\",\n   *   \"audio\": \"content\",\n   *   \"resource\": \"artifact\"\n   * }\n   */\n  outputHandling?: OutputHandling;\n\n  /**\n   * Default timeout in milliseconds for tool execution. Must be greater than 0.\n   * If not specified, tools will use their own configured timeout values.\n   */\n  defaultToolTimeout?: number;\n\n  /**\n   * `onProgress` callbacks used for tool calls.\n   */\n  onProgress?: Notifications[\"onProgress\"];\n\n  /**\n   * `beforeToolCall` callbacks used for tool calls.\n   */\n  beforeToolCall?: ToolHooks[\"beforeToolCall\"];\n\n  /**\n   * `afterToolCall` callbacks used for tool calls.\n   */\n  afterToolCall?: ToolHooks[\"afterToolCall\"];\n};\n\n/**\n * Helper function that expands a string literal OutputHandling to an object with all content types.\n * Used when applying server-level overrides to the top-level config.\n *\n * @internal\n */\nexport function _resolveDetailedOutputHandling(\n  outputHandling: OutputHandling | undefined,\n  applyDefaults: boolean = false\n): DetailedOutputHandling {\n  if (outputHandling == null) {\n    return {};\n  }\n  if (typeof outputHandling === \"string\") {\n    return Object.fromEntries(\n      callToolResultContentTypes.map((contentType) => [\n        contentType,\n        outputHandling,\n      ])\n    );\n  }\n\n  const resolved: DetailedOutputHandling = {};\n  for (const contentType of callToolResultContentTypes) {\n    if (outputHandling[contentType] || applyDefaults) {\n      resolved[contentType] =\n        outputHandling[contentType] ??\n        (contentType === \"resource\" ? \"artifact\" : \"content\");\n    }\n  }\n  return resolved;\n}\n\n/**\n * Given a base {@link OutputHandling}, apply any overrides from the override {@link OutputHandling}.\n *\n * @internal\n */\nexport function _resolveAndApplyOverrideHandlingOverrides(\n  base: OutputHandling | undefined,\n  override: OutputHandling | undefined\n): OutputHandling {\n  const expandedBase = _resolveDetailedOutputHandling(base);\n  const expandedOverride = _resolveDetailedOutputHandling(override);\n\n  return {\n    ...expandedBase,\n    ...expandedOverride,\n  };\n}\n\nexport interface CustomHTTPTransportOptions {\n  authProvider?: OAuthClientProvider;\n  headers?: Record<string, string>;\n}\n\n/**\n * Represents a resource provided by an MCP server.\n */\nexport type MCPResource = {\n  /**\n   * The URI of the resource\n   */\n  uri: string;\n  /**\n   * Human-readable name of the resource\n   */\n  name: string;\n  /**\n   * Optional description of what the resource represents\n   */\n  description?: string;\n  /**\n   * Optional MIME type of the resource content\n   */\n  mimeType?: string;\n};\n\n/**\n * Represents a resource template provided by an MCP server.\n * Resource templates are used for dynamic resources with parameterized URIs.\n */\nexport type MCPResourceTemplate = {\n  /**\n   * The URI template with parameter placeholders (e.g., \"users://{userId}/profile\")\n   */\n  uriTemplate: string;\n  /**\n   * Human-readable name of the resource template\n   */\n  name: string;\n  /**\n   * Optional description of what the resource template represents\n   */\n  description?: string;\n  /**\n   * Optional MIME type of the resource content\n   */\n  mimeType?: string;\n};\n\n/**\n * Represents the content of a resource retrieved from an MCP server.\n */\nexport type MCPResourceContent = {\n  /**\n   * The URI of the resource\n   */\n  uri: string;\n  /**\n   * Optional MIME type of the content\n   */\n  mimeType?: string;\n  /**\n   * Optional text content of the resource\n   */\n  text?: string;\n  /**\n   * Optional base64-encoded binary content of the resource\n   */\n  blob?: string;\n};\n"],"mappings":"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"}