{"version":3,"file":"client.d.cts","names":["DynamicStructuredTool","LoggingLevel","Client","ClientConfig","Connection","CustomHTTPTransportOptions","MCPResource","MCPResourceTemplate","MCPResourceContent","MCPClientError","Error","MultiServerMCPClient","Record","Promise"],"sources":["../src/client.d.ts"],"sourcesContent":["import type { DynamicStructuredTool } from \"@langchain/core/tools\";\nimport type { LoggingLevel } from \"@modelcontextprotocol/sdk/types.js\";\nimport { type Client } from \"./connection.js\";\nimport { type ClientConfig, type Connection, type CustomHTTPTransportOptions, type MCPResource, type MCPResourceTemplate, type MCPResourceContent } from \"./types.js\";\n/**\n * Error class for MCP client operations\n */\nexport declare class MCPClientError extends Error {\n    readonly serverName?: string | undefined;\n    constructor(message: string, serverName?: string | undefined);\n}\n/**\n * Client for connecting to multiple MCP servers and loading LangChain-compatible tools.\n */\nexport declare class MultiServerMCPClient {\n    #private;\n    /**\n     * Returns clone of server config for inspection purposes.\n     *\n     * Client does not support config modifications.\n     */\n    get config(): ClientConfig;\n    /**\n     * Create a new MultiServerMCPClient.\n     *\n     * @param config - Configuration object\n     */\n    constructor(config: ClientConfig | Record<string, Connection>);\n    /**\n     * Proactively initialize connections to all servers. This will be called automatically when\n     * methods requiring an active connection (like {@link getTools} or {@link getClient}) are called,\n     * but you can call it directly to ensure all connections are established before using the tools.\n     *\n     * When a server fails to connect, the client will throw an error if `onConnectionError` is \"throw\",\n     * otherwise it will skip the server and continue with the remaining servers.\n     *\n     * @returns A map of server names to arrays of tools\n     * @throws {MCPClientError} If initialization fails and `onConnectionError` is \"throw\" (default)\n     */\n    initializeConnections(customTransportOptions?: CustomHTTPTransportOptions): Promise<Record<string, DynamicStructuredTool[]>>;\n    /**\n     * Get tools from specified servers as a flattened array.\n     *\n     * @param servers - Optional array of server names to filter tools by.\n     *                 If not provided, returns tools from all servers.\n     * @param options - Optional connection options for the tool calls, e.g. custom auth provider or headers.\n     * @returns A flattened array of tools from the specified servers (or all servers)\n     *\n     * @example\n     * ```ts\n     * // Get tools from all servers\n     * const tools = await client.getTools();\n     * ```\n     *\n     * @example\n     * ```ts\n     * // Get tools from specific servers\n     * const tools = await client.getTools(\"server1\", \"server2\");\n     * ```\n     *\n     * @example\n     * ```ts\n     * // Get tools from specific servers with custom connection options\n     * const tools = await client.getTools([\"server1\", \"server2\"], {\n     *   authProvider: new OAuthClientProvider(),\n     *   headers: { \"X-Custom-Header\": \"value\" },\n     * });\n     * ```\n     */\n    getTools(...servers: string[]): Promise<DynamicStructuredTool[]>;\n    getTools(servers: string[], options?: CustomHTTPTransportOptions): Promise<DynamicStructuredTool[]>;\n    /**\n     * Set the logging level for all servers\n     * @param level - The logging level\n     *\n     * @example\n     * ```ts\n     * await client.setLoggingLevel(\"debug\");\n     * ```\n     */\n    setLoggingLevel(level: LoggingLevel): Promise<void>;\n    /**\n     * Set the logging level for a specific server\n     * @param serverName - The name of the server\n     * @param level - The logging level\n     *\n     * @example\n     * ```ts\n     * await client.setLoggingLevel(\"server1\", \"debug\");\n     * ```\n     */\n    setLoggingLevel(serverName: string, level: LoggingLevel): Promise<void>;\n    /**\n     * Get a the MCP client for a specific server. Useful for fetching prompts or resources from that server.\n     *\n     * @param serverName - The name of the server\n     * @returns The client for the server, or undefined if the server is not connected\n     */\n    getClient(serverName: string, options?: CustomHTTPTransportOptions): Promise<Client | undefined>;\n    /**\n     * List resources from specified servers.\n     *\n     * @param servers - Optional array of server names to filter resources by.\n     *                 If not provided, returns resources from all servers.\n     * @param options - Optional connection options for the resource listing, e.g. custom auth provider or headers.\n     * @returns A map of server names to their resources\n     *\n     * @example\n     * ```ts\n     * // List resources from all servers\n     * const resources = await client.listResources();\n     * ```\n     *\n     * @example\n     * ```ts\n     * // List resources from specific servers\n     * const resources = await client.listResources(\"server1\", \"server2\");\n     * ```\n     */\n    listResources(...servers: string[]): Promise<Record<string, MCPResource[]>>;\n    listResources(servers: string[], options?: CustomHTTPTransportOptions): Promise<Record<string, MCPResource[]>>;\n    /**\n     * List resource templates from specified servers.\n     *\n     * Resource templates are used for dynamic resources with parameterized URIs.\n     *\n     * @param servers - Optional array of server names to filter resource templates by.\n     *                 If not provided, returns resource templates from all servers.\n     * @param options - Optional connection options for the resource template listing, e.g. custom auth provider or headers.\n     * @returns A map of server names to their resource templates\n     *\n     * @example\n     * ```ts\n     * // List resource templates from all servers\n     * const templates = await client.listResourceTemplates();\n     * ```\n     *\n     * @example\n     * ```ts\n     * // List resource templates from specific servers\n     * const templates = await client.listResourceTemplates(\"server1\", \"server2\");\n     * ```\n     */\n    listResourceTemplates(...servers: string[]): Promise<Record<string, MCPResourceTemplate[]>>;\n    listResourceTemplates(servers: string[], options?: CustomHTTPTransportOptions): Promise<Record<string, MCPResourceTemplate[]>>;\n    /**\n     * Read a resource from a specific server.\n     *\n     * @param serverName - The name of the server to read the resource from\n     * @param uri - The URI of the resource to read\n     * @param options - Optional connection options for reading the resource, e.g. custom auth provider or headers.\n     * @returns The resource contents\n     *\n     * @example\n     * ```ts\n     * const content = await client.readResource(\"server1\", \"file://path/to/resource\");\n     * ```\n     */\n    readResource(serverName: string, uri: string, options?: CustomHTTPTransportOptions): Promise<MCPResourceContent[]>;\n    /**\n     * Close all connections.\n     */\n    close(): Promise<void>;\n    private _initializeConnection;\n    private _initializeStdioConnection;\n    /**\n     * Set up stdio restart handling\n     */\n    private _setupStdioRestart;\n    private _getHttpErrorCode;\n    private _createAuthenticationErrorMessage;\n    private _toSSEConnectionURL;\n    private _initializeStreamableHTTPConnection;\n    private _initializeSSEConnection;\n    /**\n     * Set up reconnect handling for SSE (Streamable HTTP reconnects are more complex and are handled internally by the SDK)\n     */\n    private _setupSSEReconnect;\n    private _loadToolsForServer;\n    private _attemptReconnect;\n    /**\n     * Get all tools from all servers as a flat array.\n     *\n     * @returns A flattened array of all tools\n     */\n    private _getAllToolsAsFlatArray;\n    /**\n     * Get tools from specific servers as a flat array.\n     *\n     * @param serverNames - Names of servers to get tools from\n     * @returns A flattened array of tools from the specified servers\n     */\n    private _getToolsFromServers;\n}\n//# sourceMappingURL=client.d.ts.map"],"mappings":";;;;;;;;;;AAuCgFa,cAzB3DF,oBAAAA,CAyB2DE;EA8BpCb,CAAAA,OAAAA;EAARa;;;;;EAWMA,IAAAA,MAAAA,CAAAA,CAAAA,EA3DxBV,YA2DwBU;EAWKZ;;;;;EA4BiBK,WAAAA,CAAAA,MAAAA,EA5FxCH,YA4FwCG,GA5FzBM,MA4FyBN,CAAAA,MAAAA,EA5FVF,UA4FUE,CAAAA;EAAfM;;;;;;;;;;;EAyB2CA,qBAAAA,CAAAA,sBAAAA,CAAAA,EAzGzCP,0BAyGyCO,CAAAA,EAzGZC,OAyGYD,CAzGJA,MAyGIA,CAAAA,MAAAA,EAzGWZ,qBAyGXY,EAAAA,CAAAA,CAAAA;EAARC;;;;;AAkBhE;;;;;;;;;;;;;;;;;;;;;;;;kCA7FgBA,QAAQb;wCACFK,6BAA6BQ,QAAQb;;;;;;;;;;yBAUpDC,eAAeY;;;;;;;;;;;6CAWKZ,eAAeY;;;;;;;0CAOlBR,6BAA6BQ,QAAQX;;;;;;;;;;;;;;;;;;;;;uCAqBxCW,QAAQD,eAAeN;6CACjBD,6BAA6BQ,QAAQD,eAAeN;;;;;;;;;;;;;;;;;;;;;;;+CAuBlDO,QAAQD,eAAeL;qDACjBF,6BAA6BQ,QAAQD,eAAeL;;;;;;;;;;;;;;0DAc/CF,6BAA6BQ,QAAQL;;;;WAIpFK"}