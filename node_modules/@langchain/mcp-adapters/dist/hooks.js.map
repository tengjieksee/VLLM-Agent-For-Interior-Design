{"version":3,"file":"hooks.js","names":[],"sources":["../src/hooks.ts"],"sourcesContent":["import { z } from \"zod/v3\";\nimport type { Command } from \"@langchain/langgraph\";\nimport type { EmbeddedResource } from \"@modelcontextprotocol/sdk/types.js\";\nimport type { ContentBlock } from \"@langchain/core/messages\";\nimport type { RunnableConfig } from \"@langchain/core/runnables\";\nimport type { ToolMessage } from \"@langchain/core/messages\";\n\n/**\n * state messages\n *\n * Note: this may not be defined in cases you don't use LangGraph or a LangGraph implementation like `createAgent`.\n * Also state can be defined arbitrarily by the user.\n */\nexport type State = Record<string, unknown>;\n\nconst toolCallRequestSchema = z.object({\n  serverName: z.string(),\n  name: z.string(),\n  args: z.unknown(),\n});\nexport type ToolCallRequest = z.output<typeof toolCallRequestSchema>;\n\nconst toolResultBeforeSchema = z.tuple([\n  z.custom<string | (ContentBlock | ContentBlock.Data.DataContentBlock)[]>(),\n  z.array(\n    z.union([\n      z.custom<EmbeddedResource>(),\n      z.custom<ContentBlock.Multimodal.Standard>(),\n    ])\n  ),\n]);\n\n/**\n * Tool result schema that users can return within the `afterToolCall` callback\n */\nconst toolResultSchema = z.union([\n  /**\n   * a basic string result\n   */\n  z.string(),\n  /**\n   * Command from LangGraph\n   */\n  z.custom<Command>(),\n  /**\n   * 2-tuple of content, artifact\n   */\n  toolResultBeforeSchema,\n  /**\n   * ToolMessage return\n   */\n  z.custom<ToolMessage>(),\n]);\nexport type ToolResult = z.output<typeof toolResultSchema>;\n\nconst toolCallResultSchema = z.object({\n  ...toolCallRequestSchema.shape,\n  result: toolResultBeforeSchema,\n});\n\nconst modifiedToolCallResultSchema = z.object({\n  ...toolCallRequestSchema.shape,\n  result: toolResultSchema,\n});\nexport type ModifiedToolCallResult = z.output<\n  typeof modifiedToolCallResultSchema\n>;\n\nconst toolCallModificationSchema = z\n  .object({\n    headers: z.record(z.string()),\n    args: z.unknown(),\n  })\n  .partial();\nexport type ToolCallModification = z.output<typeof toolCallModificationSchema>;\n\nexport const toolHooksSchema = z.object({\n  /**\n   * Called before a tool call is made.\n   * Allows you to modify the tool call arguments or return a different tool call.\n   *\n   * @param toolCallRequest - The tool call request\n   * @param toolCallRequest.name - The tool name\n   * @param toolCallRequest.args - The tool call arguments\n   * @param toolCallRequest.serverName - The server name\n   * @param config - The runnable config\n   * @returns The tool call modification\n   *\n   * @example\n   * ```ts\n   * const interceptor = {\n   *   beforeToolCall: (toolCallRequest, state, runtime) => {\n   *     return {\n   *       args: {\n   *         ...toolCallRequest.args,\n   *         custom: \"Custom Value\"\n   *       },\n   *       header: { \"X-Custom-Header\": \"Custom Value\" }\n   *     };\n   *   },\n   * };\n   * ```\n   */\n  beforeToolCall: z\n    .function()\n    .args(toolCallRequestSchema, z.custom<State>(), z.custom<RunnableConfig>())\n    .returns(\n      z.union([\n        z.promise(toolCallModificationSchema),\n        toolCallModificationSchema,\n        z.void(),\n        z.promise(z.void()),\n      ])\n    )\n    .optional(),\n\n  /**\n   * Called after a tool call is made.\n   * Allows you to modify the tool call result or return a different tool call result.\n   *\n   * @param toolCallResult - The tool call result\n   * @param toolCallResult.args - The tool call arguments\n   * @param toolCallResult.serverName - The server name\n   * @param toolCallResult.name - The tool name\n   * @param toolCallResult.result - The tool call result\n   * @param config - The runnable config\n   * @returns The tool call modification\n   * @example\n   * ```ts\n   * const interceptor = {\n   *   afterToolCall: (toolCallResult, state, runtime) => {\n   *     if (toolCallResult.name === \"calculator\") {\n   *       return [\"Custom Value\", []];\n   *     }\n   *     return toolCallResult.result;\n   *   },\n   * };\n   * ```\n   */\n  afterToolCall: z\n    .function()\n    .args(toolCallResultSchema, z.custom<State>(), z.custom<RunnableConfig>())\n    .returns(\n      z.union([\n        z.promise(modifiedToolCallResultSchema.pick({ result: true })),\n        modifiedToolCallResultSchema.pick({ result: true }),\n        z.void(),\n        z.promise(z.void()),\n      ])\n    )\n    .optional(),\n});\nexport type ToolHooks = z.input<typeof toolHooksSchema>;\n"],"mappings":";;;AAeA,MAAM,wBAAwB,EAAE,OAAO;CACrC,YAAY,EAAE,QAAQ;CACtB,MAAM,EAAE,QAAQ;CAChB,MAAM,EAAE,SAAS;AAClB,EAAC;AAGF,MAAM,yBAAyB,EAAE,MAAM,CACrC,EAAE,QAAwE,EAC1E,EAAE,MACA,EAAE,MAAM,CACN,EAAE,QAA0B,EAC5B,EAAE,QAA0C,AAC7C,EAAC,CACH,AACF,EAAC;;;;AAKF,MAAM,mBAAmB,EAAE,MAAM;CAI/B,EAAE,QAAQ;CAIV,EAAE,QAAiB;CAInB;CAIA,EAAE,QAAqB;AACxB,EAAC;AAGF,MAAM,uBAAuB,EAAE,OAAO;CACpC,GAAG,sBAAsB;CACzB,QAAQ;AACT,EAAC;AAEF,MAAM,+BAA+B,EAAE,OAAO;CAC5C,GAAG,sBAAsB;CACzB,QAAQ;AACT,EAAC;AAKF,MAAM,6BAA6B,EAChC,OAAO;CACN,SAAS,EAAE,OAAO,EAAE,QAAQ,CAAC;CAC7B,MAAM,EAAE,SAAS;AAClB,EAAC,CACD,SAAS;AAGZ,MAAa,kBAAkB,EAAE,OAAO;CA2BtC,gBAAgB,EACb,UAAU,CACV,KAAK,uBAAuB,EAAE,QAAe,EAAE,EAAE,QAAwB,CAAC,CAC1E,QACC,EAAE,MAAM;EACN,EAAE,QAAQ,2BAA2B;EACrC;EACA,EAAE,MAAM;EACR,EAAE,QAAQ,EAAE,MAAM,CAAC;CACpB,EAAC,CACH,CACA,UAAU;CAyBb,eAAe,EACZ,UAAU,CACV,KAAK,sBAAsB,EAAE,QAAe,EAAE,EAAE,QAAwB,CAAC,CACzE,QACC,EAAE,MAAM;EACN,EAAE,QAAQ,6BAA6B,KAAK,EAAE,QAAQ,KAAM,EAAC,CAAC;EAC9D,6BAA6B,KAAK,EAAE,QAAQ,KAAM,EAAC;EACnD,EAAE,MAAM;EACR,EAAE,QAAQ,EAAE,MAAM,CAAC;CACpB,EAAC,CACH,CACA,UAAU;AACd,EAAC"}