{"version":3,"file":"connection.d.ts","names":["SSEClientTransport","StreamableHTTPClientTransport","OAuthClientProvider","Client","MCPClient","StdioClientTransport","ResolvedStreamableHTTPConnection","ResolvedStdioConnection","ResolvedClientConfig","Record","Promise","TransportOptions","Connection","ConnectionManagerConfig","Pick","ConnectionManager"],"sources":["../src/connection.d.ts"],"sourcesContent":["import { SSEClientTransport } from \"@modelcontextprotocol/sdk/client/sse.js\";\nimport { StreamableHTTPClientTransport } from \"@modelcontextprotocol/sdk/client/streamableHttp.js\";\nimport type { OAuthClientProvider } from \"@modelcontextprotocol/sdk/client/auth.js\";\nimport { Client as MCPClient } from \"@modelcontextprotocol/sdk/client/index.js\";\nimport { StdioClientTransport } from \"@modelcontextprotocol/sdk/client/stdio.js\";\nimport type { ResolvedStreamableHTTPConnection, ResolvedStdioConnection, ResolvedClientConfig } from \"./types.js\";\nexport interface Client extends MCPClient {\n    /**\n     * Fork the client with a new set of headers, it either returns a new client or the same client if the headers are the same\n     * @param headers - The headers to fork the client with\n     * @returns The forked client\n     */\n    fork: (headers: Record<string, string>) => Promise<Client>;\n}\nexport interface TransportOptions {\n    serverName: string;\n    headers?: Record<string, string>;\n    authProvider?: OAuthClientProvider;\n}\nexport interface Connection {\n    transport: StreamableHTTPClientTransport | SSEClientTransport | StdioClientTransport;\n    client: Client;\n    transportOptions: ResolvedStdioConnection | ResolvedStreamableHTTPConnection;\n    closeCallback: () => Promise<void>;\n}\ntype ConnectionManagerConfig = Pick<ResolvedClientConfig, \"onCancelled\" | \"onInitialized\" | \"onMessage\" | \"onPromptsListChanged\" | \"onResourcesListChanged\" | \"onResourcesUpdated\" | \"onRootsListChanged\" | \"onToolsListChanged\">;\n/**\n * Manages a pool of MCP clients with different transport, server name and connection configurations.\n * This ensures we don't create multiple connections for the same server with the same configuration.\n */\nexport declare class ConnectionManager {\n    #private;\n    constructor(hooks?: ConnectionManagerConfig);\n    createClient(type: \"stdio\", serverName: string, options: ResolvedStdioConnection): Promise<Client>;\n    createClient(type: \"http\", serverName: string, options: ResolvedStreamableHTTPConnection): Promise<Client>;\n    createClient(type: \"sse\", serverName: string, options: ResolvedStreamableHTTPConnection): Promise<Client>;\n    /**\n     * Get the transport based on server name and connection configuration.\n     * @param options - The options for the transport\n     * @returns The transport\n     */\n    get(serverName: string): Client | undefined;\n    get(options: TransportOptions): Client | undefined;\n    /**\n     * Get all clients\n     * @returns All clients\n     */\n    getAllClients(): Client[];\n    /**\n     * Check if a client exists based on server name and connection configuration.\n     * @param options - The options for the transport\n     * @returns True if the client exists, false otherwise\n     */\n    has(serverName: string): boolean;\n    has(options: TransportOptions): boolean;\n    /**\n     * Delete the transport based on server name and connection configuration.\n     * @param options - The options for the transport, if not provided, all transports are deleted\n     */\n    delete(options?: TransportOptions): Promise<void>;\n    /**\n     * Get the transport for a specific client\n     * @param client - The client to get the transport for\n     */\n    getTransport(client: Client): StreamableHTTPClientTransport | SSEClientTransport | StdioClientTransport | undefined;\n    /**\n     * Get the transport for a specific connection combination\n     * @param options - The options to get the transport for\n     */\n    getTransport(options: TransportOptions): StreamableHTTPClientTransport | SSEClientTransport | StdioClientTransport | undefined;\n}\nexport {};\n//# sourceMappingURL=connection.d.ts.map"],"mappings":";;;;;;;;UAMiBG,QAAAA,SAAeC;;AAAhC;;;;EAAgCA,IAAAA,EAAAA,CAAAA,OAAAA,EAMZK,MANYL,CAAAA,MAAAA,EAAAA,MAAAA,CAAAA,EAAAA,GAMeM,OANfN,CAMuBD,QANvBC,CAAAA;AAAS"}